# es6record
	ES6:目标（期望）：是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言；

	ECMAScript 和 Javascript的关系是： 前者是后者的规格（一种规范）， 后者是前者的一种实现；正式的名称是 ESMAScript2015 标准 
****
新语法：
#### let
```
	不存在变量提升
	不允许重复的声明
	块级作用域   （es5 中只有全局作用域和函数作用域的 没有块级作用域这个概念）
	ES6引入了块级作用域，明确允许在块级作用域之中声明函数。
	对于for循环 let比var 更合适
	 声明的全部变量不属于window
	不允许重复声明。
```
#### const
```
	也是用来声明变量的 但是声明的是常量一旦声明之后常量的值就不会发生改变；
	用const声明的 变量 一旦被改变也会报错； 一旦声明变量 就必须立刻初始化；
	const 只声明而不赋值也会报错
	也是只有在块级中有效 
	对于复合型的变量 变量名不指向数据  而是指向数据的地址 const命名只保证变量名指向的地址不变 并不保证数据不变；所以将一个对象声明为常量必须非常小心；
```

#### 箭头函数：定义用一个箭头表示函数
 ```    
     箭头函数相当于匿名函数，并且简化了函数定义，箭头函数有两种格式， 一种只有一种表达式， 连{}和return都省略了 还有一种是包含多条语句，不能省略{}和return；
   this的指向
```
#### 扩展符（...）也可以将某些数据转化成数组；（将一个数组转为用逗号分隔的参数序列）；
```
扩展符背后调用的是遍历器的接口， 如果一个对象没有部署Iterator接口就无法转成数组，Array.from方法还支持类似数组的对象，所谓的类似数组的对象就是必须有length属性，因此，具有length属性的对象，都是可以通过Array.from方法转为数组
```
#### reset参数：
     一多个参数集合转为一个数组。

#### 变量的解构与赋值  数组 对象 字符串
```
	解构的概念：ES6允许按照一定的模式从数组和对象中提取值对变量进行赋值    
	当解构不成功的时候 变量的值就会是undefined；
	还有一种叫做不完全解构  即等号左边的模式 只匹配到等号右边数组的一部分， 这种情况下依然可以解构成功，
	只要某种数据结构具有Iterator接口 都可以采用数组的形式解构赋值；
	用途很广范
	交换变量之间的值
	从函数中可以返回对个值
	函数参数的定义
	提取json数据
	指定参数的默认值避免在函数中再写
```
#### 字符串的扩展：
```
	ES6为字符串添加 了Iterator接口，是的字符串也可以被for。。。of遍历
```
##### 新增三种方法：
```
	includes()：返回布尔值，表示是否找到了参数字符串。
	startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。
	endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。
        都支持第二个参数（可选）表示开始搜索的位置
    endsWith与其他两个方法不同 当参数为n时 表示针对前n个字符 ；
    repeat（）方法 返回一个新的字符串 表示重复几次
```
#### ES6 为我们提供了一个模板字符串；
```
	模版字符串是增强版的字符串，用反引号标识（在esc键的下方）可以当做普通的字符串使用，也可以来定义多行字符串，或者在字符串中嵌入遍量；
	模板字符串中嵌入变量，需要将变量名写在${} 中；
	${}中可以放入任意的JavaScript表达式 可以进行运算 以及引用对象的属性
	模版字符串还能调用函数
	如果大括号中的值不是字符串，将会按照一般的规则转为字符串，比如 大括号中如果是一个对象的话，将默认调用toString的方法；
```
#### 模板编译   <%=    %>
```
	标签模板其实不是模板，而是函数调用的一种特殊的形式，标签指的是函数， 紧跟后面的模板字符串就是他的参数；
	标签模板的的一个重要应用，就是过滤字符串，防止用户输入恶意的内容；
```
#### 多语言转换，（国际化处理）； 
#### 数组的扩展：
```
	Array.Form（）将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）；querySelectorAll 得到的是一个伪数组 可以用Array.from（） 转化成真正的数组。。才可以用forEach（）去遍历。。。
	Array.of()方法是将一组值，转成数组；
	Array.of()方法基本上可以替代Array（）或者new Array（） 并且不存在由于参数的不同而导致的重载，他的行为是非常统一的；
	Array.of()方法始终返回的是一个数组，当没有参数的，就返回一个空的数组；
	数组实例的find() 与findIndex() 
	 数组实例的find方法 用于找到第一个符合条件的数组成员，他的参数是一个回调函数，所有的数组成员依次执行毁掉函数。直到找到第一个返回值为true的成员，然后返回该成员，如果没有该成员则返回undefined；
	find方法回调函数中可以接受三个参数，依次是当前的值
```    

#### Set 和Map
```
	ES6提供了新的数据结构Set类似数组 但是里面的值是唯一的没有重复的数值
	本身是一个构造函数， 用来生成一个数据结构；
	两个对象是不相等的   --------地址  两个空对象也是不相等的；
	Map 新增的有序键值对 键值对的key 和value 都可以是任何类型的元素 可以通过set（）方法 为Map设置新的键值对  如果设置的key已经存在则用新的value覆盖
	方法： get(key) 获取指定的key值
	has(key)
	delete(key)
	Clear(key); 清除所有的成员 ， 没有返回值
	set() 返回的是Map本身 因此map也是可以使用链式语法；
```
#### 遍历器 以及 for 。。Of
```
	遍历器:”Iterator”概念：
	JavaScript原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6又添加了Map和Set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。
	遍历器（Iterator）就是这样一种机制。它是一种接口（类型），为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。
	Iterator的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费。
```
#### Class
```     
	新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。
	定一个class之后 里面包含里面有一个constructor方法 这就是构造的方法；里面的this的指向的是创建出的实例的对象；
	constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。
	Constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的                  constructor方法会被默认添加。默认返回的是实例对象 。
	类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。
	考虑到未来所有的代码，其实都是运行在模块之中，所以ES6实际上把整个语言升级到了严格模式。
	class的实例对象也是得想ES5一样需要new命名； 如果没有加上new关键字，同样会报错；
	class不存在变量的提升，只能实先定义在使用；
```
#### Super关键字：
```
	有两种用法：
	作为函数调用的时候，即super（...args） super 代表的是父类的构造函数
	作为对象调用时 super.prop  或者super.method()   super代表的是父类；注意的此时的super即可以引用父类实例属性和方法 也可以引用父类的静态方法；
	Class 继承：
	Class之间可以通过extend关键字来继承， 比ES5通过原型链实现继承，更加清晰方便，
	Super（）示父类的构造函数，用来新建父类的this对象。子类必须在constructor方法中调用super方法，否则新建的实例会出错，因为子类中没有自己的this对象而是继承父类的this对象，然后对其加工，如果不调用super（）方法，子类就得不到this对象；
	在我们之前讲过的继承中 我们是先创建子类的this对象 然后通过call和apply 将父类的属性和方法添加到this上面；
	ES6中实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。
	类的prototype 属性和 -proto-属性  在ES5之中， 每一个对象都有一个-proto-属性，指向对应的构造函数的原型对象， class构造函数同时也拥有了prototype属性和 -proto-属性  也存在两条继承连：
	子类的-proto-属性 表示构造函数的继承  总是指向父类
	子类的prototype属性的-proto-属性表示方法的继承 总是指向父类的原型对象；
	判断一个类是否是继承了另一个类  我们可以 使用 object.getPrototype()的方法；
	class取值函数以及存值函数 
```
### 总结：
1.   let可以取代var  两者的语义相同  而且let没有副作用。
     let 没有变量提升，
2.   在let与const之间 优先使用const， 尤其是在全局的环境，只设置常量的时候，
     const的声明常量有两个好处：一是 阅读代码的人立刻会意识到不应该修改这个值，二是  防止无意间修改变量所导致的错误
     所有的函数都应该设置成常量；
3.   解构赋值： 在使用数组成员对变量赋值时，优先使用解构赋值；
               函数的参数如果是对象的成员，优先使用解构赋值；
               如果函数返回多个值得时候，优先使用对象的解构赋值，而不是数组的解构赋值，这样可以添加返回值，以及更改返回值的顺序；
4.   数组的拷贝 ：  使用扩展字符串（...）
                    使用Array。from的方法 将类似的数组转成真正的数组；
5.	class  用class定义函数，取代需要的prototype的操作， 因为class的写法更简洁，易于理解；
     使用extends实现继承，因为这样更简单，不会破坏instanceof运算的危险；
